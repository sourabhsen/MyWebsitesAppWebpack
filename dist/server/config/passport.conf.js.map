{"version":3,"sources":["../../../app/config/passport.conf.js"],"names":["passport","bounds","username","minLength","maxLength","password","email","validateEmail","re","test","checkLength","string","min","max","length","serializeUser","user","done","sessionUser","_id","local","role","deserializeUser","use","usernameField","passwordField","passReqToCallback","req","signupMessage","body","process","nextTick","findOne","$or","err","newUser","toLowerCase","generateHash","save","loginMessage","validPassword"],"mappings":"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","file":"passport.conf.js","sourcesContent":["\r\n// *config/passport.conf.js*\r\n\r\n// This file contains the function which configures the PassportJS\r\n// instance passed in.\r\n\r\n// Load PassportJS strategies\r\nimport LocalStrategy from 'passport-local';\r\n\r\n// Load user model\r\nimport User from '../models/user.model.js';\r\n\r\nexport default (passport) => {\r\n\r\n  // Define length boundariess for expected parameters\r\n  let bounds = {\r\n\r\n    username : {\r\n\r\n      minLength : 3,\r\n\r\n      maxLength : 16\r\n    },\r\n\r\n    password : {\r\n\r\n      minLength : 8,\r\n\r\n      maxLength : 128\r\n    },\r\n\r\n    email : {\r\n\r\n      minLength : 5,\r\n\r\n      maxLength : 256\r\n    }\r\n  };\r\n\r\n  // Function to check a string against a REGEX for email validity\r\n  let validateEmail = (email) => {\r\n\r\n      let re = /^([\\w-]+(?:\\.[\\w-]+)*)@((?:[\\w-]+\\.)*\\w[\\w-]{0,66})\\.([a-z]{2,6}(?:\\.[a-z]{2})?)$/i;\r\n\r\n      return re.test(email);\r\n  };\r\n\r\n  // Helper function to validate string length\r\n  let checkLength = (string, min, max) => {\r\n\r\n    // If the string is outside the passed in bounds...\r\n    if(string.length > max || string.length < min)\r\n      return false;\r\n\r\n    else\r\n      return true;\r\n  };\r\n\r\n  // # Passport Session Setup\r\n\r\n  // *required for persistent login sessions*\r\n\r\n  // Passport needs the ability to serialize and deserialize users out of\r\n  // session data\r\n\r\n  // ## Serialize User\r\n  passport.serializeUser((user, done) => {\r\n\r\n    let sessionUser = {\r\n\r\n      _id : user._id,\r\n\r\n      username : user.local.username,\r\n\r\n      role : user.role\r\n    };\r\n\r\n    done(null, sessionUser);\r\n  });\r\n\r\n  // ## Deserialize User\r\n  passport.deserializeUser((sessionUser, done) => {\r\n\r\n    // The sessionUser object is different from the user mongoose\r\n    // collection\r\n\r\n    // It is actually req.session.passport.user and comes from the\r\n    // session collection\r\n    done(null, sessionUser);\r\n  });\r\n\r\n  // # Local Signup\r\n\r\n  // We are using named strategies since we have one for login and one\r\n  // for signup\r\n\r\n  // By default, if there is no name, it would just be called 'local'\r\n\r\n  passport.use('local-signup', new LocalStrategy({\r\n\r\n    // By default, the local strategy uses username and password\r\n    usernameField : 'username',\r\n\r\n    passwordField : 'password',\r\n\r\n    // Allow the entire request to be passed back to the callback\r\n    passReqToCallback : true\r\n  },\r\n\r\n  (req, username, password, done) => {\r\n\r\n    // ## Data Checks\r\n\r\n    // If the length of the username string is too long/short,\r\n    // invoke verify callback\r\n    if(!checkLength(username, bounds.username.minLength, bounds.username.maxLength)) {\r\n\r\n      // ### Verify Callback\r\n\r\n      // Invoke `done` with `false` to indicate authentication\r\n      // failure\r\n      return done(null,\r\n\r\n        false,\r\n\r\n        // Return info message object\r\n        { signupMessage : 'Invalid username length.' }\r\n      );\r\n    }\r\n\r\n    // If the length of the password string is too long/short,\r\n    // invoke verify callback\r\n    if(!checkLength(password, bounds.password.minLength, bounds.password.maxLength)) {\r\n\r\n      // ### Verify Callback\r\n\r\n      // Invoke `done` with `false` to indicate authentication\r\n      // failure\r\n      return done(null,\r\n\r\n        false,\r\n\r\n        // Return info message object\r\n        { signupMessage : 'Invalid password length.' }\r\n      );\r\n    }\r\n\r\n    // If the length of the email string is too long/short,\r\n    // invoke verify callback\r\n    if(!checkLength(req.body.email, bounds.email.minLength, bounds.email.maxLength)) {\r\n\r\n      // ### Verify Callback\r\n\r\n      // Invoke `done` with `false` to indicate authentication\r\n      // failure\r\n      return done(null,\r\n\r\n        false,\r\n\r\n        // Return info message object\r\n        { signupMessage : 'Invalid email length.' }\r\n      );\r\n    }\r\n\r\n    // If the string is not a valid email...\r\n    if(!validateEmail(req.body.email)) {\r\n\r\n      // ### Verify Callback\r\n\r\n      // Invoke `done` with `false` to indicate authentication\r\n      // failure\r\n      return done(null,\r\n\r\n        false,\r\n\r\n        // Return info message object\r\n        { signupMessage : 'Invalid email address.' }\r\n      );\r\n    }\r\n\r\n    // Asynchronous\r\n    // User.findOne will not fire unless data is sent back\r\n    process.nextTick(() => {\r\n\r\n      // Find a user whose email or username is the same as the passed\r\n      // in data\r\n\r\n      // We are checking to see if the user trying to login already\r\n      // exists\r\n      User.findOne({\r\n\r\n        // Model.find `$or` Mongoose condition\r\n        $or : [\r\n\r\n          { 'local.username' : username },\r\n\r\n          { 'local.email' : req.body.email }\r\n        ]\r\n      }, (err, user) => {\r\n\r\n        // If there are any errors, return the error\r\n        if (err)\r\n          return done(err);\r\n\r\n        // If a user exists with either of those ...\r\n        if(user) {\r\n\r\n          // ### Verify Callback\r\n\r\n          // Invoke `done` with `false` to indicate authentication\r\n          // failure\r\n          return done(null,\r\n\r\n            false,\r\n\r\n            // Return info message object\r\n            { signupMessage : 'That username/email is already ' +\r\n            'taken.' }\r\n          );\r\n\r\n        } else {\r\n\r\n          // If there is no user with that email or username...\r\n\r\n          // Create the user\r\n          let newUser = new User();\r\n\r\n          // Set the user's local credentials\r\n\r\n          // Combat case sensitivity by converting username and\r\n          // email to lowercase characters\r\n          newUser.local.username = username.toLowerCase();\r\n\r\n          newUser.local.email = req.body.email.toLowerCase();\r\n\r\n          // Hash password with model method\r\n          newUser.local.password = newUser.generateHash(password);\r\n\r\n          // Save the new user\r\n          newUser.save((err) => {\r\n\r\n            if (err)\r\n              throw err;\r\n\r\n            return done(null, newUser);\r\n          });\r\n        }\r\n      });\r\n    });\r\n  }));\r\n\r\n  // # Local Login\r\n\r\n  // We are using named strategies since we have one for login and one\r\n  // for signup\r\n\r\n  // By default, if there is no name, it would just be called 'local'\r\n\r\n  passport.use('local-login', new LocalStrategy({\r\n\r\n    // By default, local strategy uses username and password\r\n    usernameField : 'username',\r\n\r\n    passwordField : 'password',\r\n\r\n    // Allow the entire request to be passed back to the callback\r\n    passReqToCallback : true\r\n  },\r\n\r\n  (req, username, password, done) => {\r\n\r\n    // ## Data Checks\r\n\r\n    // If the length of the username string is too long/short,\r\n    // invoke verify callback.\r\n    // Note that the check is against the bounds of the email\r\n    // object. This is because emails can be used to login as\r\n    // well.\r\n    if(!checkLength(username, bounds.username.minLength, bounds.email.maxLength)) {\r\n\r\n      // ### Verify Callback\r\n\r\n      // Invoke `done` with `false` to indicate authentication\r\n      // failure\r\n      return done(null,\r\n\r\n        false,\r\n\r\n        // Return info message object\r\n        { loginMessage : 'Invalid username/email length.' }\r\n      );\r\n    }\r\n\r\n    // If the length of the password string is too long/short,\r\n    // invoke verify callback\r\n    if(!checkLength(password, bounds.password.minLength, bounds.password.maxLength)) {\r\n\r\n      // ### Verify Callback\r\n\r\n      // Invoke `done` with `false` to indicate authentication\r\n      // failure\r\n      return done(null,\r\n\r\n        false,\r\n\r\n        // Return info message object\r\n        { loginMessage : 'Invalid password length.' }\r\n      );\r\n    }\r\n\r\n    // Find a user whose email or username is the same as the passed\r\n    // in data\r\n\r\n    // Combat case sensitivity by converting username to lowercase\r\n    // characters\r\n    User.findOne({\r\n\r\n      // Model.find `$or` Mongoose condition\r\n      $or : [\r\n\r\n        { 'local.username' : username.toLowerCase() },\r\n\r\n        { 'local.email' : username.toLowerCase() }\r\n      ]\r\n    }, (err, user) => {\r\n\r\n      // If there are any errors, return the error before anything\r\n      // else\r\n      if (err)\r\n        return done(err);\r\n\r\n      // If no user is found, return a message\r\n      if (!user) {\r\n\r\n        return done(null,\r\n\r\n          false,\r\n\r\n          { loginMessage : 'That user was not found. ' +\r\n          'Please enter valid user credentials.' }\r\n        );\r\n      }\r\n\r\n      // If the user is found but the password is incorrect\r\n      if (!user.validPassword(password)) {\r\n\r\n        return done(null,\r\n\r\n          false,\r\n\r\n          { loginMessage : 'Invalid password entered.' });\r\n      }\r\n\r\n      // Otherwise all is well; return successful user\r\n      return done(null, user);\r\n    });\r\n  }));\r\n};\r\n"]}
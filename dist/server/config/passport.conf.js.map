{"version":3,"sources":["../../../app/config/passport.conf.js"],"names":["passport","bounds","username","minLength","maxLength","password","email","validateEmail","re","test","checkLength","string","min","max","length","serializeUser","user","done","sessionUser","_id","local","role","deserializeUser","use","LocalStrategy","usernameField","passwordField","passReqToCallback","req","signupMessage","body","process","nextTick","User","findOne","$or","err","newUser","toLowerCase","generateHash","save","loginMessage","validPassword"],"mappings":"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","file":"passport.conf.js","sourcesContent":["\n// *config/passport.conf.js*\n\n// This file contains the function which configures the PassportJS\n// instance passed in.\n\n// Load PassportJS strategies\nimport LocalStrategy from 'passport-local';\n\n// Load user model\nimport User from '../models/user.model.js';\n\nexport default (passport) => {\n\n  // Define length boundariess for expected parameters\n  let bounds = {\n\n    username : {\n\n      minLength : 3,\n\n      maxLength : 16\n    },\n\n    password : {\n\n      minLength : 8,\n\n      maxLength : 128\n    },\n\n    email : {\n\n      minLength : 5,\n\n      maxLength : 256\n    }\n  };\n\n  // Function to check a string against a REGEX for email validity\n  let validateEmail = (email) => {\n\n      let re = /^([\\w-]+(?:\\.[\\w-]+)*)@((?:[\\w-]+\\.)*\\w[\\w-]{0,66})\\.([a-z]{2,6}(?:\\.[a-z]{2})?)$/i;\n\n      return re.test(email);\n  };\n\n  // Helper function to validate string length\n  let checkLength = (string, min, max) => {\n\n    // If the string is outside the passed in bounds...\n    if(string.length > max || string.length < min)\n      return false;\n\n    else\n      return true;\n  };\n\n  // # Passport Session Setup\n\n  // *required for persistent login sessions*\n\n  // Passport needs the ability to serialize and deserialize users out of\n  // session data\n\n  // ## Serialize User\n  passport.serializeUser((user, done) => {\n\n    let sessionUser = {\n\n      _id : user._id,\n\n      username : user.local.username,\n\n      role : user.role\n    };\n\n    done(null, sessionUser);\n  });\n\n  // ## Deserialize User\n  passport.deserializeUser((sessionUser, done) => {\n\n    // The sessionUser object is different from the user mongoose\n    // collection\n\n    // It is actually req.session.passport.user and comes from the\n    // session collection\n    done(null, sessionUser);\n  });\n\n  // # Local Signup\n\n  // We are using named strategies since we have one for login and one\n  // for signup\n\n  // By default, if there is no name, it would just be called 'local'\n\n  passport.use('local-signup', new LocalStrategy({\n\n    // By default, the local strategy uses username and password\n    usernameField : 'username',\n\n    passwordField : 'password',\n\n    // Allow the entire request to be passed back to the callback\n    passReqToCallback : true\n  },\n\n  (req, username, password, done) => {\n\n    // ## Data Checks\n\n    // If the length of the username string is too long/short,\n    // invoke verify callback\n    if(!checkLength(username, bounds.username.minLength, bounds.username.maxLength)) {\n\n      // ### Verify Callback\n\n      // Invoke `done` with `false` to indicate authentication\n      // failure\n      return done(null,\n\n        false,\n\n        // Return info message object\n        { signupMessage : 'Invalid username length.' }\n      );\n    }\n\n    // If the length of the password string is too long/short,\n    // invoke verify callback\n    if(!checkLength(password, bounds.password.minLength, bounds.password.maxLength)) {\n\n      // ### Verify Callback\n\n      // Invoke `done` with `false` to indicate authentication\n      // failure\n      return done(null,\n\n        false,\n\n        // Return info message object\n        { signupMessage : 'Invalid password length.' }\n      );\n    }\n\n    // If the length of the email string is too long/short,\n    // invoke verify callback\n    if(!checkLength(req.body.email, bounds.email.minLength, bounds.email.maxLength)) {\n\n      // ### Verify Callback\n\n      // Invoke `done` with `false` to indicate authentication\n      // failure\n      return done(null,\n\n        false,\n\n        // Return info message object\n        { signupMessage : 'Invalid email length.' }\n      );\n    }\n\n    // If the string is not a valid email...\n    if(!validateEmail(req.body.email)) {\n\n      // ### Verify Callback\n\n      // Invoke `done` with `false` to indicate authentication\n      // failure\n      return done(null,\n\n        false,\n\n        // Return info message object\n        { signupMessage : 'Invalid email address.' }\n      );\n    }\n\n    // Asynchronous\n    // User.findOne will not fire unless data is sent back\n    process.nextTick(() => {\n\n      // Find a user whose email or username is the same as the passed\n      // in data\n\n      // We are checking to see if the user trying to login already\n      // exists\n      User.findOne({\n\n        // Model.find `$or` Mongoose condition\n        $or : [\n\n          { 'local.username' : username },\n\n          { 'local.email' : req.body.email }\n        ]\n      }, (err, user) => {\n\n        // If there are any errors, return the error\n        if (err)\n          return done(err);\n\n        // If a user exists with either of those ...\n        if(user) {\n\n          // ### Verify Callback\n\n          // Invoke `done` with `false` to indicate authentication\n          // failure\n          return done(null,\n\n            false,\n\n            // Return info message object\n            { signupMessage : 'That username/email is already ' +\n            'taken.' }\n          );\n\n        } else {\n\n          // If there is no user with that email or username...\n\n          // Create the user\n          let newUser = new User();\n\n          // Set the user's local credentials\n\n          // Combat case sensitivity by converting username and\n          // email to lowercase characters\n          newUser.local.username = username.toLowerCase();\n\n          newUser.local.email = req.body.email.toLowerCase();\n\n          // Hash password with model method\n          newUser.local.password = newUser.generateHash(password);\n\n          // Save the new user\n          newUser.save((err) => {\n\n            if (err)\n              throw err;\n\n            return done(null, newUser);\n          });\n        }\n      });\n    });\n  }));\n\n  // # Local Login\n\n  // We are using named strategies since we have one for login and one\n  // for signup\n\n  // By default, if there is no name, it would just be called 'local'\n\n  passport.use('local-login', new LocalStrategy({\n\n    // By default, local strategy uses username and password\n    usernameField : 'username',\n\n    passwordField : 'password',\n\n    // Allow the entire request to be passed back to the callback\n    passReqToCallback : true\n  },\n\n  (req, username, password, done) => {\n\n    // ## Data Checks\n\n    // If the length of the username string is too long/short,\n    // invoke verify callback.\n    // Note that the check is against the bounds of the email\n    // object. This is because emails can be used to login as\n    // well.\n    if(!checkLength(username, bounds.username.minLength, bounds.email.maxLength)) {\n\n      // ### Verify Callback\n\n      // Invoke `done` with `false` to indicate authentication\n      // failure\n      return done(null,\n\n        false,\n\n        // Return info message object\n        { loginMessage : 'Invalid username/email length.' }\n      );\n    }\n\n    // If the length of the password string is too long/short,\n    // invoke verify callback\n    if(!checkLength(password, bounds.password.minLength, bounds.password.maxLength)) {\n\n      // ### Verify Callback\n\n      // Invoke `done` with `false` to indicate authentication\n      // failure\n      return done(null,\n\n        false,\n\n        // Return info message object\n        { loginMessage : 'Invalid password length.' }\n      );\n    }\n\n    // Find a user whose email or username is the same as the passed\n    // in data\n\n    // Combat case sensitivity by converting username to lowercase\n    // characters\n    User.findOne({\n\n      // Model.find `$or` Mongoose condition\n      $or : [\n\n        { 'local.username' : username.toLowerCase() },\n\n        { 'local.email' : username.toLowerCase() }\n      ]\n    }, (err, user) => {\n\n      // If there are any errors, return the error before anything\n      // else\n      if (err)\n        return done(err);\n\n      // If no user is found, return a message\n      if (!user) {\n\n        return done(null,\n\n          false,\n\n          { loginMessage : 'That user was not found. ' +\n          'Please enter valid user credentials.' }\n        );\n      }\n\n      // If the user is found but the password is incorrect\n      if (!user.validPassword(password)) {\n\n        return done(null,\n\n          false,\n\n          { loginMessage : 'Invalid password entered.' });\n      }\n\n      // Otherwise all is well; return successful user\n      return done(null, user);\n    });\n  }));\n};\n"]}